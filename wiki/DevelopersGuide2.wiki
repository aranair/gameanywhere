#summary For developers only.
#labels Phase-Requirements,Phase-Design,Phase-Implementation,Featured
#sidebar TOC

*Welcome to !GameAnywhere.*

!GameAnywhere is a file synchronization software that enables gamers to bypass the hassle on reconfiguring game settings and easily have their saved game data with them anywhere, anytime.

<wiki:toc max_depth="2" />

----

= Getting Started =

In this section, we would introduce the basic features of !GameAnywhere and what you will need to develop !GameAnywhere.

== Software Requirements ==
  * Windows operating system, XP and above.
  * .Net 3.5 framework installed.


== Features of !GameAnywhere==

 * Carry your personal game data in a thumb drive or have it saved in your free online account.


 * Easily sync your game data between PC, thumb drive and your GameAnywhere online account.


 * Automatically detects the games installed on the computer and offer you the appropriate synchronization options.


 * Restores the computer to its original state after you're done playing on the computer with the files you have synchronized.


 * Supports World of Warcraft, Warcraft 3: The Frozen Throne, FIFA 10, Football Manager 2010, Football Manager 2009, The Sims 3, Dragon Age Origins, Borderlands and Abuse. 

 * No installation needed.

 * Free and Open-Source.


== Screenshots ==

http://lh3.ggpht.com/_-Xzk-2Bdr-I/S8MOvsVBCoI/AAAAAAAAANA/HDz3CNO2RZw/startup.JPG

http://lh4.ggpht.com/_-Xzk-2Bdr-I/S8MOwBGEpxI/AAAAAAAAANE/2ImMt0p0zv0/choosegame.jpg

----

= Software Architecture =

In this section, we will give you a high level overview of the components in !GameAnywhere.

http://lh6.ggpht.com/_-Xzk-2Bdr-I/S7HEsTA3TgI/AAAAAAAAALA/wPhf7Ql4slM/highleveldiagram.JPG

This diagram depicts what happens in the program. 

The Controller is declared and the Controller starts up the GUI. The GUI interacts with the user. 

In a typical synchronization scenario, the user indicates the direction of the synchronization first. The GUI will request information regarding the games from Controller, which in turn calls GameLibrary for the information to return to GUI. 

After the user selects the games to synchronize, GUI will then create a list of SyncAction with the games' information and send it to Controller for synchronization. Controller will then provide the information to OfflineSync class to process.

----


= Software Data Structure = 

This section describes the various classes that were used to store information.


== Game ==

Game is a class that stores the necessary information regarding a Game, i.e. game file path, install path, game name. 

=== See Also === 
  * [DevelopersGuide2#GameLibrary_Class GameLibrary Class]



== !SyncError ==

SyncError stores the information for an synchronization error. It would contain the unsuccessful sync file/folder path, the process that encountered this error and lastly, the error message.

=== See Also ===
  * [DevelopersGuide2#OfflineSync_Class OfflineSync Class]



== !SyncAction ==

SyncAction contains the necessary information to sync a game. A [DevelopersGuide2#Game Game] object and a list of [DevelopersGuide2#SyncError SyncError] would be wrapped in a SyncAction object. The unsuccessfully synced files will be related to the [DevelopersGuide2#Game Game] object. Initially, it contains an empty list of !SyncError when it is created by the GUI. 

!SyncAction also contain the sync action, which indicates what type of game files to be synced. There are basically two types of games files, saved games files and game configuration files. User can choose to sync either one or both.

=== See Also ===
  * [DevelopersGuide2#OfflineSync_Class OfflineSync Class]
  * [DevelopersGuide2#GameLibrary_Class GameLibrary Class]


----

= Class Summary = 

== !GameLibrary Class ==

The GameLibrary class, contains all the methods and information to initialize installed games into a list of games, that will contain all the appropriate paths to the config files and saved game files of each individual game.

It will also resolve and return the common set of games that are found in both the source and target paths according to the synchronization direction
chosen by the user, through the method !GetGameList(direction). The direction of synchronization must be properly defined with this method.


== !OfflineSync Class ==
This class handles the file/folder manipulation on the computer as well as on the external storage device. The sync direction determine how the game files are transferred.

=== Exception ===
  * !CreateFolderFailedException will be thrown if [DevelopersGuide2#SyncFolder !SyncFolder] cannot be created.

=== See Aslo ===
   * [DevelopersGuide2#Game_Files_Storage_Structure Game Files Storage Structure]
   * [DevelopersGuide2#Offline_Synchronization Offline Synchronization]


== !OnlineSync Class ==

//@Wilson/Nick, fill in a simple description of your class.  

----

= Game Files Storage Structure =

In !GameAnywhere, we are concerned with the two types of game files. They are *Configuration* files and *Saved Game* files. 

Games files on the computer are detected automatically (see [DevelopersGuide2#Games_Detection Games Detection]). 

This is how game files are stored on the external device:

A general structure looks like this:
  * !GameAnywhere.exe
  * !SyncFolder
    * Game 1
      * config
      * savedGame
    * Game 2
      * config
    * ...


*Example:* 

http://game-anywhere.com/images/folder_structure.jpg

Use camel case for subfolder names i.e. "savedGame". 

== !SyncFolder ==

!GameAnywhere would create a folder to store all the games files that you would want to save. This folder is called *!SyncFolder*. It would be located at the same directory as !GameAnywhere.exe.

The subfolders in !SyncFolder are the game folder(s). Each of the game folder is named after a game. 

Configuration and Saved game files are stored in their respective folder under a game folder. 

----

= Games Detection =

For version 1.0, game detection is hard coded, by reading a registry key for each individual game and finding the *installpath* variable value of the game's registry entry.

By first checking the existence of the registry key, then checking the existence of the game folder at the install path, we can determine if a particular game exists on the system running the application. The paths to files and folders for each game are hard coded, and these paths will be initialized into the corresponding config list, and saved game list of a Game Object. Other information about a game will also be found and loaded into the Game Object which serves primarily as a data encapsulation.


----

= Adding Games =

To edit the supported games in !GameAnywhere, simply edit the [DeveloperGuide2#gamev3.txt_Example gamev3.txt] file located in the same directory as !GameAnywhere.exe.

== Variables needed to add a game ==

=== Critical game information ===
|| *Variable Name* || *Description* ||
|| Game || The Game name.||
|| !RegValue ||  The name of the registry entry, in the registry folder, that contains the install path. ||
|| !RegKey ||  Path to registry folder of game.||
|| !RegType ||  KLM for HKEY_LOCAL_MACHINE or HKCU for HKEY_CURRENT_USER||

<br>
=== Below are paths for files ===
|| *Variable Name* || *Description* ||
|| !ConfigParentPath||  Full path to the parent path of all the config game folders/files. ||
|| !ConfigPathList||  Full paths to config files separated by comma. ||
|| !SearchConfigparent||  Regex search to handle batch processing or variable folder/file names for config files. ||
|| !SaveParentPath || Full path to the parent path of all the saved game folders/files. ||
|| !SavePathList || Full paths to saved game files separated by comma.	 ||
|| !SearchSaveParent||  Regex search to handle batch processing or variable folder/file names for saved games. ||

<br>
=== Reserved Words/Variables that can be used in the paths for files ===
|| *Reserved Words/Variables* || *Description* ||
|| !InstallPathVar || Can be used to replace the InstallPath recorded in the registry.|| 
|| !DocumentsPath || Can be used to replace the document paths of running machine, etc: “C:\Users\Tom\Documents\” || 
|| !RegistrySoftwarePath || Can be used to replace the registry software path for the different types of OS. For example: “RegistrySoftwarePath\EA Sports\FIFA 10” (with HKLM) will evaluate to “HKEY_LOCAL_MACHINE\SOFTWARE\EA Sports\FIFA 10” for non-64bit OS users and“HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\EA Sports\FIFA 10” for 64bit OS users. ||


== Syntax rules to comply ==
 * All critical game information variable must be present.
 * If config files exist, !ConfigParentPath must be present, likewise for saved game files/!SaveParentPath.
 * [DeveloperGuide2#gamev3.txt_Example `[ENDGAME]`] after the end of each game (see example below).
 * Comma can be used to separate entries for !ConfigPathList, !SearchConfigParent, !SavePathList and !SearchSaveParent.
 * To write a comment line, begin the line with #. Example: 
{{{
#This is a line of comments.
}}}
 * There can only be one entry each for !ConfigParentPath and !SaveParentPath.
 * !SearchConfigParent/!SearchSaveParent are for [http://msdn.microsoft.com/en-us/library/30wbz966%28VS.71%29.aspx regex] searching to handle variable folder or file names. Example:
{{{
SearchSaveParent = A.*, B.*
Possible Result: "A.boa", "B.ho", "B.man"
* is a wildcard that will match any character(s). 
It will search in the SaveParentPath for all possible files. 
Then these will be added into the saved game list. 
An alternative way albeit slower is to add the full paths of these files into SavePathList separated by comma.
}}}


== gamev3.txt Example == 
{{{
Game=FIFA 10
RegValue=Install Dir
RegKey=RegistrySoftwarePath\EA Sports\FIFA 10
RegType=HKLM
ConfigPathList=DocumentsPath\FIFA 10\user
ConfigParentPath=DocumentsPath\FIFA 10
SaveParentPath=DocumentsPath\FIFA 10
SearchSaveParent=A. *,B. *,C. *,D. *,I. *,J. *
[ENDGAME]

Game=Dragon Age Origins
RegValue=Path
RegKey=RegistrySoftwarePath\BioWare\Dragon Age
RegType=HKLM
ConfigPathList=DocumentsPath\BioWare\Dragon Age\Settings
ConfigParentPath=DocumentsPath\BioWare\Dragon Age
SavePathList=DocumentsPath\BioWare\Dragon Age\Characters
SaveParentPath=DocumentsPath\BioWare\Dragon Age
[ENDGAME]

Game=Batman Arkham Asylum
RegValue=Install Directory
RegKey=RegistrySoftwarePath\RocksteadyLtd\Batman Arkham Asylum
RegType=HKLM
ConfigPathList=DocumentsPath\Eidos\Batman Arkham Asylum\BmGame\Config\UserInput.ini,DocumentsPath\Eidos\Batman Arkham Asylum\BmGame\Config\UserGame.ini
ConfigParentPath=DocumentsPath\Eidos\Batman Arkham Asylum\BmGame\Config
SavePathList=DocumentsPath\Eidos\Batman Arkham Asylum\SaveData
SaveParentPath=DocumentsPath\Eidos\Batman Arkham Asylum
[ENDGAME]
}}}
-----

= Offline Synchronization =

Offline synchronization includes synchronizing between the computer and the [DevelopersGuide2#SyncFolder SyncFolder]. [DevelopersGuide2#SyncFolder SyncFolder] is located on an external device.

http://farm3.static.flickr.com/2776/4478572596_fc9a553fca_o.jpg

== External Device to Computer Sync == 

*Steps for synchronizing from External storage device to Computer:*
 # Create a backup folder in the game file parent directory.
   * If backup folder exists, skip backup process.
 # Move original game files in the computer into the backup folder to complete backup process.
   * If backup is not successful, skip sync for game.
 # Copy the game files in the external storage device into the computer.


== Computer to External Device Sync ==

*Steps for synchronizing from Computer to External storage device:*
 # Remove existing game files in external storage device.
 # Create the necessary game folder structure in the external storage device.
 # Copy game files from computer into the new directory.


== Restore Computer to Original Game State ==

*Steps for restore:*
 # Remove game files on computer.
 # Move game files from backup folder into it's original directory.
 # Remove backup folder.

-----

= Online Synchronization =

//@Wilson/Nick, explain how online sync is executed.

== See Also ==
  * [DevelopersGuide2#Login_System Login System]
  * [DevelopersGuide2#GameAnywhere_Account_Registration_System GameAnywhere Account Registration System]

-----

= Thumb Drive and Web Synchronization =

Web and Thumb Drive Synchronization is a two-way file-level synchronization operation. The aim of this operation is to ensure that the game files stored on the web are the same as the game files stored on the thumb drive. The files on both sides will be checked and compared against a metadata file that is stored on the thumb drive and the user would then be asked to resolve any outstanding conflicts that cannot be automatically be resolved. 

== Metadata file ==

The metadata file is a serialized MetaData object.

  * The !MetaData object contains a Dictionary<String, String> !FileTable which stores the paths of the files as keys, and their MD5 Hash codes as the corresponding values.
  * The keys are not specific to local or remote paths, only including the path starting from the game name (i.e. “Warcraft III/config/CustomKeys.txt”).
  * The metadata file stores the state of the files that are previously successfully synchronized between the Web and Thumb Drive.
  * The metadata file is created/updated only when Thumb Drive and Web Synchronization is executed and not the other modes of synchronization. (See [DevelopersGuide2#Synchronization_Algorithm_/_Conflict_Resolution Web and Thumb Drive Synchronization Algorithm)


== Synchronization Algorithm / Conflict Resolution == 

Since the metadata file stores the state of the previous successful synchronization, it can be used to compare if the files have been change, deleted or newly created.

=== Metadata and Syncing ===
When The WebAndThumbSync object is instantiated, it will:
  * Create the MetaData object by de-serializing the metadatafile (localMeta).
  * Create a MetaData object of the current state of the files in the Thumb Drive (localHash).
  * Create a MetaData object of the current state of the files on the Web (webHash).

=== Checking Conflicts ===
The CheckConflicts() method is called to check for conflicts, which either can automatically be resolved, or requires the user resolution.
Conflicts are checked by comparing the three MetaData objects created, iterating through each entry of the FileTable data member.

=== Scenario: No Conflict === 

*Automatic Conflict Resolution* 
|| *File exists in localHash* || *File exists in localMeta* || *File exists in webHash* || *localHash vs.localMeta* || *webHash vs.localMeta* || *Result* || *Action*|| 
|| Y || Y  || Y || Hashes are the same. || Hashes are the same. || No changes since last sync. || None|| 
|| Y || Y ||  Y || Hashes are the same. || Hashes are different. ||  File on web has changed. ||  Download || 
|| Y || Y || Y || Hashes are different. || Hashes are the same. ||  File on thumb drive has changed. ||  Upload || 
|| Y || Y || N || Hashes are the same. || - ||  File on web has been deleted. || !DeleteLocal || 
|| N || Y || Y || - || Hashes are the same. || File on thumb has been deleted || !DeleteWeb ||
|| Y || N || N || - || - || File on thumb drive is newly created. || Upload || 
|| N || N ||  Y || - || - ||  File on web is newly created. || Download ||  
|| N || Y ||  N || - || - || File on both thumb and web has been deleted. || !DeleteMetadata || 
Y = Yes, 
N = No


=== Scenario: Conflict(s) === 

*Manual Conflict Resolution by User*

|| *File exists in localHash* || *File exists in localMeta* || *File exists in webHash* || *localHash vs.localMeta* || *webHash vs.localMeta* || *Result* || *Conflict*|| 
|| Y || Y || Y || Hashes are different. || Hashes are different.|| Both thumb drive and web has changed. || !UploadOrDownload ||
|| Y || N ||Y || - || - || File on both thumb drive and web are newly created || !UploadOrDownload ||
|| Y || N || Y ||

----

= Login System =
== Overview ==
To provide users with their own gameanywhere account, we need a database to store account information and Amazon Web Services(AWS) SimpleDB was chosen.

== How the Components Interact ==
[http://img30.imageshack.us/img30/381/onlinecomponents.jpg]

The User component consists of user related functions such as Login, Register, ChangePassword and Logout.

In AWS SimpleDB, a table is called a domain while rows are identified as items, and columns are attributes. The unique key is known as the item name. So here is an overview of the SimpleDB component, it is meant for database functions like:
 * Inserting an item into Amazon SimpleDB, use the InsertItem method.
 * Getting an item’s attribute value, use the GetAttribute method.
 * Updating an item’s attribute value, use the UpdateAttributeValue method.
 * Checking if an item exists in the domain, use the ItemExists method.

AmazonSimpleDBClient component mainly deals with amazon simpleDB web service directly by sending requests and receiving responses from it. It hides all the low level amazon webservices programming like authentication and error handling. You may download the latest Amazon Web Services SDK for .NET from http://aws.amazon.com/sdkfornet/.

== Data structure of Domain ==
The domain that has been created and we will be using is called “UserAccounts”. Each item has the following attributes: ItemName, Password, ActivationStatus, ActivationKey. The ItemName acts like a unique key, there should be no duplicates in the domain. Every attribute is of string datatype as it is a limitation of AWS SimpleDB.

----

= !GameAnywhere Account Registration System =

//@Nick, :)


----

= API Reference =

Click here for !GameAnywhere [http://api.game-anywhere.com/index.html library].